<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@5HT"><meta name="twitter:creator" content="@5HT"><meta name="twitter:image" content="https://groupoid.space/card2.png?v=1"><meta property="og:title" content="Groupoid Infinity"><meta property="og:image" content="https://groupoid.space/card2.png?v=1"><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="https://groupoid.space"><meta property="og:description" content="The Language of Space"><link rel="stylesheet" href="https://groupoid.space/main.css?v=10"><title>SHEAF</title><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script><script>window.MathJax = { jax: ["input/TeX", "input/MathML", "input/AsciiMath", "output/CommonHTML", "output/NativeMML"],
                        TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "autoload-all.js"] },
                        extensions: ["tex2jax.js", "asciimath2jax.js", "mml2jax.js", "MathMenu.js", "MathZoom.js"],
                        "HTML-CSS": { imageFont: null },
                        AuthorInit: function() {
                            MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function() {
                                var TEX = MathJax.InputJax.TeX;
                                TEX.Definitions.Add({
                                    macros: {
                                      llparenthesis: ['Macro', '\\mathopen{\u2987}'],
                                      rrparenthesis: ['Macro', '\\mathclose{\u2988}'],
                                      llbracket:     ['Macro', '\\mathopen{\u27E6}'],
                                      rrbracket:     ['Macro', '\\mathclose{\u27E7}'],
                                      incmap:        ['Macro', '\\mathclose{\u21AA}'],
                                    }
                                });
                            });
                        },
                        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']],
                                   processEscapes: true }
                    };
</script></head><body class="content"><article class="main"><div class="om"><section><h1>SHEAF MODEL <br> OF TYPE THEORY</h1></section></div><aside><a href="https://tonpa.guru">Максим Сохацький</a><time>Published: 01 JAN 2019</time></aside><div class="om"><section><figure>$$\def\mapright#1{\xrightarrow{{#1}}}
  \def\mapdown#1{\Big\downarrow\rlap{\raise2pt{\scriptstyle{#1}}}}
  \def\mapdiagl#1{\vcenter{\searrow}\rlap{\raise2pt{\scriptstyle{#1}}}}
  \def\mapdiagr#1{\vcenter{\swarrow}\rlap{\raise2pt{\scriptstyle{#1}}}}
$$</figure><p>This article requires as prerequisites an article about the formalization
of the category theory and topos thepry:
<a href="https://groupoid.space/mltt/topos">Formal Set Topos</a>.
Presheaf model of type theory could be seen as generalization of the notion of Kripke model.
</p></section><section><h1>INTRO</h1><p><b>Definition</b> (Presheaf over $C$).
A presheaf over a category $C$ is a functor
from $C^{op}$ to the category of $\mathrm{Set}$.
We denote $\mathrm{Ob}_C$ as $I,J,K$ and $\mathrm{Hom}_C$ as $f,g$,
identity morphisms $1_I : I \rightarrow I$,
composition $f\ g : K \rightarrow I$ for $g : K \rightarrow J$, $f : I \rightarrow J$.
This means a presheaf $\mathrm{PSh}_C$ is given by a family of sets $C_I$
and restriction maps $u \mapsto u\ f$, $C_I \rightarrow C_J$ for
$f:J \rightarrow I$ satisfying the laws $u\ 1_I = u$ and $(uf)g=u(fg)$ for
$g:K \rightarrow J$.</p><p><b>Definition</b> (Yoneda presheaf $\mathrm{Yo}_X$).
Any object $X$ of base category $C$ defines a
presheaf $\mathrm{Yo}_X$ represented by $X$.
This presheaf $\mathrm{Yo}_X$ assigns to each object $I$ in $C$
the set of arrows $I \rightarrow X$. Given anarrow $f:J \rightarrow I$
composition with f maps an arrow $I \rightarrow X$ to an arrow $J \rightarrow X$.
In other words $\mathrm{Yo}_X(J)$
then a set of maps $I \rightarrow J$ and the restriction maps defined by composition.
</p><h1>DEPENDENT TYPES</h1><p><b>Definition</b> (Type).
A type is interpreted as a presheaf $A$, a family of sets $A_I$ with restriction maps
$u \mapsto uf, A_I \rightarrow A_J$ for $f: J\rightarrow I$. A dependent type
B on A is interpreted by a presheaf on category of elements of $A$: the objects
are pairs $(I,u)$ with $u : A_I$ and morphisms $f: (J,v) \rightarrow (I,u)$ are
maps $f : J \rightarrow$ such that $v = uf$. A dependent type B is thus given
by a family of sets $B(I,u)$ and restriction maps $B(I,u) \rightarrow B(J,uf)$.</p><p>We think of $A$ as a type and $B$ as a family of presheves $B(x)$ varying $x:A$.
The operation $\Pi(x:A)B(x)$ generalizes the semantics of
implication in a Kripke model.</p><p><b>Defintion</b> (Pi). An element $w:[\Pi(x:A)B(x)](I)$ is a family
of functions $w_f : \Pi(u:A(J))B(J,u)$ for $f : J \rightarrow I$ such
that $(w_f u)g=w_{fg}(ug)$ when $u:A(J)$ and $g:K\rightarrow J$.</p><p><b>Defintion</b> (Sigma). The set $\Sigma(x:A)B(x)$ is the set
of pairs $(u,v)$ when $u:A(I),v:B(I,u)$ and restriction map $(u,v)f=(u f,v f)$.
</p><h1>CUBICAL TYPES</h1><p>The identity types modeled with another presheaf, the presheaf on Lawvere
category of distributive lattices (theory of de Morgan algebras) denoted
with $\Box$ &mdash; $F : \Box^{op} \rightarrow \mathrm{Set}$.
</p><h1>SIMPLIFICATION</h1><p>What if we take not a category as the underlying objects for sheaves
but monoidal structure just to simplify the model. The we get the following</p><code>isPSh (G: U) (M: monoid): U
  = (c: G -> M.1.1 -> G)
  * (left: (g: G) -> Path G (c g M.2.2.2.1) g)
  * ((g: G) (t r: M.1.1) -> Path G (c (c g t) r)
                                   (c g (M.2.1 t r)))

PSh (M: monoid): U
  = (G: U)
  * (isPSh G M)

NatPSh (M: monoid) (D G: PSh M): U
  = (sigma: D.1 -> G.1)
  * ((s: D.1)(t: M.1.1) -> Path G.1 (G.2.1 (sigma s) t)
                                    (sigma (D.2.1 s t)))

isType (M: monoid) (G: PSh M) (A: G.1 -> U): U
  = (star: (g: G.1) -> A g -> (t: M.1.1) -> A (G.2.1 g t))
  * (coe1: (g: G.1) (t: M.1.1)
 -> Path U (A g) (A (G.2.1 g t)))
  * (coe2: (g: G.1) (t r: M.1.1)
 -> Path U (A(G.2.1(G.2.1 g t)r))(A(G.2.1 g(M.2.1 t r))))
  * (left: (g: G.1) (a: A g)
 -> PathP (coe1 g M.2.2.2.1) a (star g a M.2.2.2.1))
  * ((g:G.1)(a:A g) (t r: M.1.1)
 -> PathP (coe2 g t r) (star (G.2.1 g t) (star g a t) r)
                       (star g a (M.2.1 t r)))

Type (M: monoid) (G: PSh M): U
  = (A: G.1 -> U)
  * isType M G A</code></section></div></article><footer class="footer"><a href="https://tonpa.guru/"><img class="footer__logo" src="https://longchenpa.guru/seal.png" width="50"></a><span class="footer__copy">2016&mdash;2019 &copy; <a href="https://groupoid.space/" style="color:Lavender;">Groupoid Infinity</a></span></footer><script src="https://groupoid.space/bundle.js"></script><script src="https://groupoid.space/highlight.js?v=9"></script></body></html>